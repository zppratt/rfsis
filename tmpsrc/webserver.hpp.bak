#ifndef _6193_WEB_SERVER_H_
#define _6193_WEB_SERVER_H_

#define BSIZE 2048

#include <time.h>
#include <stdio.h>
#include <fcntl.h>
#include <errno.h>

#include "pico_device.h"
#include "pico_ipv4.h"
#include "pico_stack.h"
#include "pico_socket.h"
#include "pico_dev_tap.h"
#include "pico_icmp4.h"

extern int errno;

class webServer{
public:
  webServer(struct pico_device *dev, uint16_t port, int read, int pos, int len, int flag, char *ipv4_addr, char *netmask);
  void deferred_exit(pico_time __attribute__((unused)) now, void *arg);
  int read_html_file(struct pico_socket *s);
  struct pico_device* init_picotcp();
  void setup_server();
  int send_resp(struct pico_socket *s);
  void cb_tcpserver(uint16_t ev, struct pico_socket *s);
  void setDev(struct pico_device *dev);
  struct pico_device getDev();

private:
  struct pico_device *dev;
  uint16_t port;
  int read;
  int pos;
  int len;
  int flag;
  char recvbuf[BSIZE];
  char *ipv4_addr;
  char *netmask;
  char *p_website;
};

webServer::webServer(struct pico_device *dev, uint16_t port,
  int read, int pos, int len, int flag,
  char *ipv4_addr, char *netmask){
    this->dev = dev;
    this->port = port;
    this->read = read;
    this->pos = pos;
    this->len = len;
    this->flag = flag;
    this->ipv4_addr = ipv4_addr;
    this->netmask = netmask;
    p_website = "src/website.html";
}

void webServer::deferred_exit(pico_time __attribute__((unused)) now, void *arg) {
    if (arg) {
        free(arg);
        arg = NULL;
    }

    printf("%s: quitting\n", __FUNCTION__);
    exit(0);
}

int webServer::read_html_file(struct pico_socket *s) {
    // Since the compiler cant tell the difference between read and read
    int red = 0;
    char buffer[BSIZE];

    // We want to use a file descriptors because we want to treat
    // the file as a stream instead of with handlers
    int fd = open(p_website, O_RDONLY);
    if(fd < 0) {
        printf("ERROR: %s\n", strerror(errno));
        return -1;
    }

    while((red = read(fd, buffer, sizeof(buffer))) != 0) {
        if(red < 0) {
            printf("ERROR: %s\n", strerror(errno));
            return -1;
        }
        pico_socket_write(s, buffer, red);
    }

    close(fd);

    return red;
}



struct pico_device* webServer::init_picotcp(){
  struct pico_device *dev;
  struct pico_ip4 ipaddr, netmask, local;

  pico_string_to_ipv4("wlan0", &local.addr);

  dev = pico_ipv4_link_find(&local);

  if(!dev) {
      printf("FAIL!\n");
      return NULL;
  }

  pico_string_to_ipv4(ipv4_addr, &ipaddr.addr);
  pico_string_to_ipv4(netmask, &netmask.addr);
  pico_ipv4_link_add(dev, ipaddr, netmask);

  return dev;
}

void webServer::setup_server(){
  struct pico_socket *listen_socket;
  uint16_t port;
  int ret;

  struct pico_ip4 address = {0};
  port = short_be(port); // Have to use their short be thing...

  listen_socket = pico_socket_open(PICO_PROTO_IPV4, PICO_PROTO_TCP,
          &cb_tcpserver);

  if (!listen_socket) {
      printf("Could not open socket!\n");
      exit(1);
  }

  ret = pico_socket_bind(listen_socket, &address, &port);
  if (ret < 0) {
      printf("could not bind socket\n");
      exit(1);
  }

  ret = pico_socket_listen(listen_socket, 40);
  if (ret < 0) {
      printf("could not listen\n");
      exit(1);
  }
}


int webServer::send_resp(struct pico_socket *s){
  int w, ww = 0;

  if (len >  pos) {
      do {
          w = pico_socket_write(s, recvbuf + pos, len - pos);
          if (w > 0) {
              pos += w;
              ww += w;
              if (pos >= len) {
                  pos = 0;
                  len = 0;
              }
          }
      } while ((w > 0) && (pos < len));
  }

  return ww;
}

void webServer::cb_tcpserver(uint16_t ev, struct pico_socket *s){
  printf("tcpecho | env = %u\n", ev);

  if (ev & PICO_SOCK_EV_RD) {
      if (flag & PICO_SOCK_EV_CLOSE) {
          printf("Fin received!\n");
      }

      while (len < BSIZE) {
          read = pico_socket_read(s, recvbuf + len, BSIZE - len);
          if (read > 0) {
              len += read;
              flag &= ~(PICO_SOCK_EV_RD);
          } else {
              flag |= PICO_SOCK_EV_RD;
              break;
          }
      }

      if (flag & PICO_SOCK_EV_WR) {
          flag &= ~PICO_SOCK_EV_WR;
          send_resp(s);
      }
  }

  if (ev & PICO_SOCK_EV_CONN) {
      struct pico_socket *sock_a = {0};
      struct pico_ip4 orig       = {0};
      uint16_t port              = 0;
      char peer[30]              = {0};
      uint32_t ka_val            = 0;
      int yes                    = 1;

      sock_a = pico_socket_accept(s, &orig, &port);

      pico_ipv4_to_string(peer, orig.addr);
      printf("Connection established with %s:%d\n", peer, short_be(port));
      pico_socket_setoption(sock_a, PICO_TCP_NODELAY, &yes);

      ka_val = 5;
      pico_socket_setoption(sock_a, PICO_SOCKET_OPT_KEEPCNT, &ka_val);

      ka_val = 30000;
      pico_socket_setoption(sock_a, PICO_SOCKET_OPT_KEEPIDLE, &ka_val);

      ka_val = 5000;
      pico_socket_setoption(sock_a, PICO_SOCKET_OPT_KEEPINTVL, &ka_val);

  }

  if (ev & PICO_SOCK_EV_FIN) {
      printf("Socket closed. Exiting normally\n");
      pico_timer_add(2000, deferred_exit, NULL);
  }

  if (ev & PICO_SOCK_EV_ERR) {
      printf("Socket error: %s. Time to quit this shiznit!\n",
              strerror(pico_err));
      exit(1);
  }

  if (ev & PICO_SOCK_EV_CLOSE) {
      printf("Socket received close from peer.\n");
      if (flag & PICO_SOCK_EV_RD) {
          pico_socket_shutdown(s, PICO_SHUT_WR);
          printf("Called shutdown write, ev = %d\n", ev);
      }

  }

  if (ev & PICO_SOCK_EV_WR) {
      read_html_file(s);
      pico_socket_shutdown(s, PICO_SHUT_WR);
  }
}

void webServer::setDev(struct pico_device *dev){
  this->dev = dev;
}

struct pico_device webServer::getDev(){
  return dev;
}


#endif
